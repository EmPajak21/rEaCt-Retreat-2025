import multiprocessing
from typing import Dict, Any, List
import pandas as pd
import numpy as np
import os
import sys

# Determine the parent directory path
parent_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))

# Add the parent directory to sys.path if it's not already there
if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)

from bio_model import (
    evaluate_student_solution,
    genetic_algorithm,
    generate_training_data,
    generate_test_data,
    true_model_day2,
    true_model_day3,
    plot_results,
    DEFAULT_PARAMS,
    DAY3_PARAMS,
    TERM_NAMES,
)

# Define initial conditions
initial_conditions = [
    [0.1, 10.0, 0.0, 1.0],  # Low X, high S, medium I
    [0.2, 8.0, 0.0, 2.0],  # Medium X, medium S, high I
    [0.3, 6.0, 0.0, 0.5],  # High X, low S, medium I
    [0.3, 8.0, 0.2, 1.0],  # High X, medium S, high I
]


def load_training_data_from_csv(csv_file: str) -> List[Dict[str, Any]]:
    """
    Load training data from a CSV file and convert it to the same format as generated by
    generate_training_data.

    Parameters
    ----------
    csv_file : str
        Path to the CSV file.

    Returns
    -------
    List[Dict[str, Any]]
        A list of dictionaries, each with keys "t", "data", and "initial_conditions".
    """
    df = pd.read_csv(csv_file)
    training_data = []

    # Group rows by experiment (assumes there is a column 'experiment')
    for experiment, group in df.groupby("experiment"):
        # Sort by time to ensure the data are in the correct order
        group = group.sort_values(by="time")
        t = group["time"].to_numpy()

        # Construct the data array.
        data = np.column_stack(
            [
                group["biomass"].to_numpy(),
                group["substrate"].to_numpy(),
                group["product"].to_numpy(),
                group["inhibitor"].to_numpy(),
            ]
        )

        # Retrieve initial conditions.
        init_biomass = group["initial_biomass"].iloc[0]
        init_substrate = group["initial_substrate"].iloc[0]
        init_inhibitor = group["initial_inhibitor"].iloc[0]
        # Check if there is a column for initial product; if not, default to 0.
        if "initial_product" in group.columns:
            init_product = group["initial_product"].iloc[0]
        else:
            init_product = 0.0

        initial_conditions = [
            init_biomass,
            init_substrate,
            init_product,
            init_inhibitor,
        ]

        training_data.append(
            {"t": t, "data": data, "initial_conditions": initial_conditions}
        )

    return training_data


def run_genetic_algorithm_with_timeout(
    training_data: List[Dict[str, Any]],
    timeout: int = 20,
    generations: int = 1000, 
    population_size: int = 30,
    mutation_rate: float = 0.1,
) -> Dict[str, Any]:
    # Create a Manager dictionary to share the best individual.
    manager = multiprocessing.Manager()
    best_container = manager.dict()

    # Prepare the process: note we pass best_container to the genetic algorithm.
    process = multiprocessing.Process(
        target=genetic_algorithm,
        kwargs={
            "training_data": training_data,
            "generations": generations,
            "population_size": population_size,
            "mutation_rate": mutation_rate,
            "best_container": best_container,
        },
    )

    process.start()
    process.join(timeout)  # Wait up to 20 seconds

    # If still running after timeout, terminate it.
    if process.is_alive():
        print("Timeout reached: terminating genetic algorithm process.")
        process.terminate()
        process.join()

    # Retrieve and return the best individual (or None if none was set).
    best_individual = best_container.get("best", None)
    return best_individual


if __name__ == "__main__":
    # Assume training_data is defined, e.g.:
    training_data = load_training_data_from_csv("day_2_md/training_data_day2.csv")

    best = run_genetic_algorithm_with_timeout(training_data, timeout=20)
    print("Best individual found (within 20s):")
    print(best)
